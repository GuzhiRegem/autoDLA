AutoDLA includes a variety of features to improve quality of life for the developer.

Let's create a base Object called `User` and work with it in this page to explore different concepts:
```python
from autodla import Object, primary_key
from autodla.dbs import PostgresDB

class User(Object):
    id: primary_key = primary_key.auto_increment()
    name: str
    age: int

db = PostgresDB()
db.attach([User])

```

---
## Data Generation
AutoDLA can automatically generate data using the `DataGenerator` class.

Usage:
```python
from autodla.utils import DataGenerator
```
this class includes a variety of `staticmethods` that allow you to generate distinct types of data:
```python
# Create 3 Users and save them into a list of users
users = []
for i in range(3):
    usr = User.new(
        name=DataGenerator.name()
        age=DataGenerator.age()
    )
    users.append(usr)
```
This generates 3 users and saves them into the `users` variable

| id | name | age |
| -- | -- | -- |
| ee102517-ea1b-466f-8c2a-61d49c1e7425 | Karen | 20 |
| c0e9b676-32dc-4add-b1a5-b60e464afd30 | William | 10 |
| d4c12093-756a-4438-9bf1-c7fc0cb563ed | Susan | 15 |

---
## Data Audit by design
Tables generated by AutoDLA are transactional tables by design. This allows for more in depth data analysis without the hussle of generating and mantaining this infrastructures.

For the example we are working with, in the DB the table `public.users` was generated defined with the next columns :

| column_name | data_type |
| -- | -- |
| `dla_object_id` | uuid |
| `dla_modified_at` | timestamp |
| `dla_modified_by` | text |
| `dla_operation` | text |
| `dla_is_current` | boolean |
| `dla_is_active` | boolean |
| id | uuid |
| age | integer |
| name | text |

The rows currently in the table are these:

| id | name | age | `dla_object_id`| `dla_modified_at`| `dla_modified_by`| `dla_operation`| `dla_is_current`| `dla_is_active`|
| -- | -- | -- | -- | -- | -- | -- | -- | -- |
| ee102517-ea1b-466f-8c2a-61d49c1e7425 | Karen | 20 | b83e5016-acd7-476f-8b30-f19154cdbbbf | '03-04-2025 00:00:00' | SYSTEM | INSERT | True | True |
| c0e9b676-32dc-4add-b1a5-b60e464afd30 | William | 10 | a300842d-da73-41b0-bb97-998601254769 | '03-04-2025 00:00:00' | SYSTEM | INSERT | True | True |
| d4c12093-756a-4438-9bf1-c7fc0cb563ed | Susan | 15 | 81b5ba22-f381-416f-865f-997c6970d664 | '03-04-2025 00:00:00' | SYSTEM | INSERT | True | True |

but if we apply some change, its going to be applied in the table, saving the changes
```python
# get Susan
usr = users[-1]
# modify Susan
usr.update(age=25)
```
Resulting in the table now being (see how a row was added and the previous last in the `is_current` field was modified):

| id | name | age | `dla_object_id`| `dla_modified_at`| `dla_modified_by`| `dla_operation`| `dla_is_current`| `dla_is_active`|
| -- | -- | -- | -- | -- | -- | -- | -- | -- |
| ee102517-ea1b-466f-8c2a-61d49c1e7425 | Karen | 20 | b83e5016-acd7-476f-8b30-f19154cdbbbf | '03-04-2025 00:00:00' | SYSTEM | INSERT | True | True |
| c0e9b676-32dc-4add-b1a5-b60e464afd30 | William | 10 | a300842d-da73-41b0-bb97-998601254769 | '03-04-2025 00:00:00' | SYSTEM | INSERT | True | True |
| d4c12093-756a-4438-9bf1-c7fc0cb563ed | Susan | 15 | 81b5ba22-f381-416f-865f-997c6970d664 | '03-04-2025 00:00:00' | SYSTEM | INSERT | False | True |
| 531a0f7b-fc95-4e71-90c9-ad7d7c00720d | Susan | 25 | 81b5ba22-f381-416f-865f-997c6970d664 | '03-04-2025 00:01:15' | SYSTEM | UPDATE | True | True |

This data can be accessed in 2 ways:

- [`User.get_table_res()`](/reference/object/#get_table_reslimit-int-10-only_current-bool-true-only_active-bool-true-listdict): returning the complete table for the model User
- or for each user with the method [`usr.history()`](/reference/object/#historykwargs-dict-dictstr-listdict): returning the complete table for the specific instance

The working memory will have always the last version of each object:

| id | name | age |
| -- | -- | -- |
| ee102517-ea1b-466f-8c2a-61d49c1e7425 | Karen | 20 |
| c0e9b676-32dc-4add-b1a5-b60e464afd30 | William | 10 |
| d4c12093-756a-4438-9bf1-c7fc0cb563ed | Susan | 25 |

## Automatic relationships
Because AutoDLA uses the Model abstraction instead of the Table abstraction (used by most ORMs), each Model can have multiple tables representing it's data. AutoDLA handles the background tables required to fullfil the specified relationship.

To show this, let's create a new Model:
```python
class Group(Object):
    id: primary_key = primary_key.auto_increment()
    group_name: str
    participants: list[User]
```
as you see, participants is a list of Users, to function AutoDLA is creating 2 tables for this model:

- `public.group`: This represents the data that doesn't uses a relationship
- `public.group__participants__user`: This creates a table for the specific relationship with the other Model

When the program memory is updated for you to use the python objects, a JOIN clause is automatically applied in the background.

In practice, once you setup the models, you can just use them as any other Python object, AutoDLA will handle everything.
```python
# Group creation
grp = Group.new(
    group_name = 'Group 1',
    participants = [
        users[0]
    ]
)

# Group modification: add another user
grp.update(participants=grp.participants + [users[1]])

# Reference the user from the group
usr = grp.participants[0]
print(usr)
### User( name=Karen , age=20 )

# Modify user from the group
grp.participants[0].update(age=grp.participants[0].age + 1)
print(users[0])
### User( name=Karen , age=21 )
```

## Filtering
AutoDLA includes a built-in method to turn lambda functions into SQL Querys, thanks to this, to filter data in AutoDLA you need to write a function to apply to get specific data

```python
# get by name
filtered_users = User.filter(lambda x: x.name == 'Karen')

# get by age
filtered_users = User.filter(lambda x: x.age > 18)

# use python functions
filtered_users = User.filter(lambda x: x.name.startswith('K'))
```